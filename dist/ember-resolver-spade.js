// ==========================================================================
// Project:   Ember - JavaScript Application Framework
// Copyright: Copyright 2013 Stefan Penner and Ember App Kit Contributors
// License:   Licensed under MIT license
//            See https://raw.github.com/stefanpenner/ember-jj-abrams-resolver/master/LICENSE
// ==========================================================================


minispade.register('ember-resolver/container-debug-adapter', "(function() {/*globals define registry requirejs */\n\ndefine(\"ember/container-debug-adapter\",\n  [],\n  function() {\n    \"use strict\";\n\n  // Support Ember < 1.5-beta.4\n  // TODO: Remove this after 1.5.0 is released\n  if (typeof Ember.ContainerDebugAdapter === 'undefined') {\n    return null;\n  }\n  /*\n   * This module defines a subclass of Ember.ContainerDebugAdapter that adds two\n   * important features:\n   *\n   *  1) is able provide injections to classes that implement `extend`\n   *     (as is typical with Ember).\n   */\n\n  var ContainerDebugAdapter = Ember.ContainerDebugAdapter.extend({\n    /**\n      The container of the application being debugged.\n      This property will be injected\n      on creation.\n\n      @property container\n      @default null\n    */\n    // container: null, LIVES IN PARENT\n\n    /**\n      The resolver instance of the application\n      being debugged. This property will be injected\n      on creation.\n\n      @property resolver\n      @default null\n    */\n    // resolver: null,  LIVES IN PARENT\n    /**\n      Returns true if it is possible to catalog a list of available\n      classes in the resolver for a given type.\n\n      @method canCatalogEntriesByType\n      @param {string} type The type. e.g. \"model\", \"controller\", \"route\"\n      @return {boolean} whether a list is available for this type.\n    */\n    canCatalogEntriesByType: function(type) {\n      return true;\n    },\n\n    /**\n      Returns the available classes a given type.\n\n      @method catalogEntriesByType\n      @param {string} type The type. e.g. \"model\", \"controller\", \"route\"\n      @return {Array} An array of classes.\n    */\n    catalogEntriesByType: function(type) {\n      var entries = requirejs.entries,\n          module,\n          types = Ember.A();\n\n      var makeToString = function(){\n        return this.shortname;\n      };\n\n      for(var key in entries) {\n        if(entries.hasOwnProperty(key) && key.indexOf(type) !== -1)\n        {\n          // // TODO return the name instead of the module itself\n          // module = require(key, null, null, true);\n\n          // if (module && module['default']) { module = module['default']; }\n          // module.shortname = key.split(type +'s/').pop();\n          // module.toString = makeToString;\n\n          // types.push(module);\n          types.push(key.split(type +'s/').pop());\n        }\n      }\n\n      return types;\n    }\n  });\n\n  ContainerDebugAdapter['default'] = ContainerDebugAdapter;\n  return ContainerDebugAdapter;\n});\n\n})();\n//@ sourceURL=ember-resolver/container-debug-adapter");minispade.register('ember-resolver/core', "(function() {/*globals define registry requirejs */\n\ndefine(\"ember/resolver\",\n  [],\n  function() {\n    \"use strict\";\n\n    if (typeof requirejs.entries === 'undefined') {\n      requirejs.entries = requirejs._eak_seen;\n    }\n\n  /*\n   * This module defines a subclass of Ember.DefaultResolver that adds two\n   * important features:\n   *\n   *  1) The resolver makes the container aware of es6 modules via the AMD\n   *     output. The loader's _moduleEntries is consulted so that classes can be\n   *     resolved directly via the module loader, without needing a manual\n   *     `import`.\n   *  2) is able to provide injections to classes that implement `extend`\n   *     (as is typical with Ember).\n   */\n\n  function classFactory(klass) {\n    return {\n      create: function (injections) {\n        if (typeof klass.extend === 'function') {\n          return klass.extend(injections);\n        } else {\n          return klass;\n        }\n      }\n    };\n  }\n\n if (!(Object.create && !Object.create(null).hasOwnProperty)) {\n \tthrow new Error(\"This browser does not support Object.create(null), please polyfil with es5-sham: http://git.io/yBU2rg\");\n }\n\n function makeDictionary() {\n\t var cache = Object.create(null);\n\t cache['_dict'] = null;\n\t delete cache['_dict'];\n\t return cache;\n }\n\n\n  var underscore = Ember.String.underscore;\n  var classify = Ember.String.classify;\n  var get = Ember.get;\n\n  function parseName(fullName) {\n    /*jshint validthis:true */\n\n    if (fullName.parsedName === true) { return fullName; }\n\t\t\n\t\t var prefixParts = fullName.split('@');\n\t\t var prefix;\n\t\t\n\t\t if (prefixParts.length === 2) {\n\t\t\t if (prefixParts[0].split(':')[0] === 'view') {\n\t\t\t\t prefixParts[0] = prefixParts[0].split(':')[1];\n\t\t\t\t prefixParts[1] = 'view:' + prefixParts[1];\n\t\t\t }\n\t\t\t\n\t\t\t prefix = prefixParts[0];\n\t\t }\n\t\t\n\t\t var nameParts = prefixParts[prefixParts.length - 1].split(\":\");\n\t\t var type = nameParts[0], fullNameWithoutType = nameParts[1];\n\t\t var name = fullNameWithoutType;\n\t\t var namespace = get(this, 'namespace');\n\t\t var root = namespace;\n\n    return {\n    \tparsedName: true,\n      fullName: fullName,\n      prefix: prefix || this.prefix({type: type}),\n      type: type,\n      fullNameWithoutType: fullNameWithoutType,\n      name: name,\n      root: root,\n      resolveMethodName: \"resolve\" + classify(type)\n    };\n  }\n\n  function chooseModuleName(moduleEntries, moduleName) {\n    var underscoredModuleName = Ember.String.underscore(moduleName);\n\n    if (moduleName !== underscoredModuleName && moduleEntries[moduleName] && moduleEntries[underscoredModuleName]) {\n      throw new TypeError(\"Ambiguous module names: `\" + moduleName + \"` and `\" + underscoredModuleName + \"`\");\n    }\n\n    if (moduleEntries[moduleName]) {\n      return moduleName;\n    } else if (moduleEntries[underscoredModuleName]) {\n      return underscoredModuleName;\n    } else {\n      // workaround for dasherized partials:\n\t\t\t// something/something/-something => something/something/_something\n\t\t\tvar partializedModuleName = moduleName.replace(/\\/-([^\\/]*)$/, '/_$1');\n\n      if (moduleEntries[partializedModuleName]) {\n        Ember.deprecate('Modules should not contain underscores. ' +\n                        'Attempted to lookup \"'+moduleName+'\" which ' +\n                        'was not found. Please rename \"'+partializedModuleName+'\" '+\n                        'to \"'+moduleName+'\" instead.', false);\n\n        return partializedModuleName;\n      } else {\n        return moduleName;\n      }\n    }\n  }\n\n  function resolveRouter(parsedName) {\n    /*jshint validthis:true */\n\n    var moduleName, tmpModuleName, prefixes, podPrefixes, moduleEntries, _routers = [], router, prefix;\n\n    prefixes = this.namespace.modulePrefix || this.namespace.modulePrefixes;\n    podPrefixes = this.namespace.podModulePrefix || this.namespace.podModulePrefixes || prefixes;\n    if(typeof prefixes === \"string\") {\n      prefixes = [prefixes];\n    }    \n    if(typeof podPrefixes === \"string\") {\n      podPrefixes = [podPrefixes];\n    }\n\n    moduleEntries = requirejs.entries;\n\n    var pluralizedType = parsedName.type + 's';\n    var name = parsedName.fullNameWithoutType;\n\n    Ember.assert('module prefix must be defined', prefixes);\n    var Router = Ember.Router.extend();\n\n    for(var p = 0; p < podPrefixes.length; p++) {\n      // POD format\n      tmpModuleName = podPrefixes[p] + \"/\" + parsedName.fullNameWithoutType + \"/\" + parsedName.type;\n      if(moduleEntries[tmpModuleName]) {\n        router = require(tmpModuleName, null, null, true /* force sync */);\n        if(router && router[\"default\"]) { router = router[\"default\"];}\n        if(router) { _routers.push(router);}\n      }\n    }\n\n    if(!moduleName && name === 'main') {\n      for(p = 0; p < prefixes.length; p++) {\n        tmpModuleName = prefixes[p] + '/' + parsedName.type;\n        if (moduleEntries[tmpModuleName]) {\n          router = require(tmpModuleName, null, null, true /* force sync */);\n          if(router && router[\"default\"]) { router = router[\"default\"];}\n          if(router) { _routers.push(router);}\n        }\n      }\n    }\n\n    for(p = 0; p < prefixes.length; p++) {\n      tmpModuleName = prefixes[p] + \"/\" + pluralizedType + \"/\" + parsedName.fullNameWithoutType;\n      if(moduleEntries[tmpModuleName]) {\n        router = require(tmpModuleName, null, null, true /* force sync */);\n        if(router && router[\"default\"]) { router = router[\"default\"];}\n        if(router) {\n          _routers.push(router);\n        }\n      }\n    }\n\n    Router.map(function() {\n      for(var r = 0; r < _routers.length; r++) {\n        _routers[r].apply(this);\n      }      \n    });\n\n    return Router;\n  }\n\n  function resolveMenu(parsedName) {\n    /*jshint validthis:true */\n\n    var moduleName, tmpModuleName, prefixes, podPrefixes, moduleEntries, _menus = [], menu, prefix;\n\n    prefixes = this.namespace.modulePrefix || this.namespace.modulePrefixes;\n    podPrefixes = this.namespace.podModulePrefix || this.namespace.podModulePrefixes || prefixes;\n    if(typeof prefixes === \"string\") {\n      prefixes = [prefixes];\n    }    \n    if(typeof podPrefixes === \"string\") {\n      podPrefixes = [podPrefixes];\n    }\n\n    moduleEntries = requirejs.entries;\n\n    var pluralizedType = parsedName.type + 's';\n    var name = parsedName.fullNameWithoutType;\n\n    Ember.assert('module prefix must be defined', prefixes);\n\n    for(var p = 0; p < podPrefixes.length; p++) {\n      // POD format\n      tmpModuleName = podPrefixes[p] + \"/\" + parsedName.fullNameWithoutType + \"/\" + parsedName.type;\n      if(moduleEntries[tmpModuleName]) {\n        menu = require(tmpModuleName, null, null, true /* force sync */);\n        if(menu && menu[\"default\"]) { menu = menu[\"default\"];}\n        if(menu) { _menus.push(menu);}\n      }\n    }\n\n    if(!moduleName && name === 'main') {\n      for(p = 0; p < prefixes.length; p++) {\n        tmpModuleName = prefixes[p] + '/' + parsedName.type;\n        if (moduleEntries[tmpModuleName]) {\n          menu = require(tmpModuleName, null, null, true /* force sync */);\n          if(menu && menu[\"default\"]) { menu = menu[\"default\"];}\n          if(menu) { _menus.push(menu);}\n        }\n      }\n    }\n\n    for(p = 0; p < prefixes.length; p++) {\n      tmpModuleName = prefixes[p] + \"/\" + pluralizedType + \"/\" + parsedName.fullNameWithoutType;\n      if(moduleEntries[tmpModuleName]) {\n        menu = require(tmpModuleName, null, null, true /* force sync */);\n        if(menu && menu[\"default\"]) { menu = menu[\"default\"];}\n        if(menu) {\n          _menus.push(menu);\n        }\n      }\n    }\n\n    var Menu = Ember.Object.extend();\n\n    var _result = [];\n    _menus.forEach(function(_m) {\n        _m = _m.create({});\n        _m.get(\"items\").forEach(function(_item) {_result.push(_item);});\n    });\n\n    _result.sort(function(a,b){return a.get(\"sort\") - b.get(\"sort\");});\n\n    Menu.reopen({\n      \"menu-items\": Ember.A(_result)\n    });\n      \n\n    return Menu;\n  }\n\n  function resolveString(parsedName) {\n    /*jshint validthis:true */\n\n    var l, moduleName, tmpModuleName, prefixes, podPrefixes, moduleEntries, _strs = [], str, prefix;\n\n    prefixes = this.namespace.modulePrefix || this.namespace.modulePrefixes;\n    podPrefixes = this.namespace.podModulePrefix || this.namespace.podModulePrefixes || prefixes;\n    if(typeof prefixes === \"string\") {\n      prefixes = [prefixes];\n    }    \n    if(typeof podPrefixes === \"string\") {\n      podPrefixes = [podPrefixes];\n    }\n\n    moduleEntries = requirejs.entries;\n\n    var pluralizedType = parsedName.type + 's';\n    var name = parsedName.fullNameWithoutType;\n\n    Ember.assert('module prefix must be defined', prefixes);\n\n    for(var p = 0; p < podPrefixes.length; p++) {\n      // POD format\n      tmpModuleName = podPrefixes[p] + \"/\" + parsedName.fullNameWithoutType + \"/\" + parsedName.type;\n      if(moduleEntries[tmpModuleName]) {\n        str = require(tmpModuleName, null, null, true /* force sync */);\n        if(str && str[\"default\"]) { str = str[\"default\"];}\n        if(str) { _strs.push(str);}\n      }\n    }\n\n    if(!moduleName && name === 'main') {\n      for(p = 0; p < prefixes.length; p++) {\n        tmpModuleName = prefixes[p] + '/' + parsedName.type;\n        if (moduleEntries[tmpModuleName]) {\n          str = require(tmpModuleName, null, null, true /* force sync */);\n          if(str && str[\"default\"]) { str = str[\"default\"];}\n          if(str) { _strs.push(str);}\n        }\n      }\n    }\n\n    for(p = 0; p < prefixes.length; p++) {\n      tmpModuleName = prefixes[p] + \"/\" + pluralizedType + \"/\" + parsedName.fullNameWithoutType;\n      if(moduleEntries[tmpModuleName]) {\n        str = require(tmpModuleName, null, null, true /* force sync */);\n        if(str && str[\"default\"]) { str = str[\"default\"];}\n        if(str) {\n          _strs.push(str);\n        }\n      }\n    }\n\n    var str = {};\n\n    var _result = [];\n    _strs.forEach(function(_s) {\n        for(l in _s) {\n          str[l] = str[l] || {};\n          $.extend(str[l],_s[l]);\n        }\n    });\n\n    return str;\n  }\n\n  function resolveOther(parsedName) {\n    /*jshint validthis:true */\n\n    Ember.assert('module prefix must be defined', this.namespace.modulePrefix);\n\n    var normalizedModuleName = this.findModuleName(parsedName);\n\n    if (normalizedModuleName) {\n      var module = require(normalizedModuleName, null, null, true /* force sync */);\n\n      if (module && module['default']) { module = module['default']; }\n\n      if (module === undefined) {\n        throw new Error(\" Expected to find: '\" + parsedName.fullName + \"' within '\" + normalizedModuleName + \"' but got 'undefined'. Did you forget to `export default` within '\" + normalizedModuleName + \"'?\");\n      }\n\n      if (this.shouldWrapInClassFactory(module, parsedName)) {\n        module = classFactory(module);\n      }\n\n      return module;\n    } \n      \n    return this._super(parsedName);\n  }\n  // Ember.DefaultResolver docs:\n  //   https://github.com/emberjs/ember.js/blob/master/packages/ember-application/lib/system/resolver.js\n  var Resolver = Ember.DefaultResolver.extend({\n    resolveRouter: resolveRouter,\n    resolveString: resolveString,\n    resolveMenu: resolveMenu,\n    resolveOther: resolveOther,\n    resolveTemplate: resolveOther,\n  \tpluralizedTypes: null,\n    \n    makeToString: function(factory, fullName) {\n      return '' + this.namespace.modulePrefix + '@' + fullName + ':';\n    },\n    parseName: parseName,\n    shouldWrapInClassFactory: function(module, parsedName){\n      return false;\n    },\n\n    init: function() {\n\t\t\tthis._super();\n\t\t\tthis._normalizeCache = makeDictionary();\n\n\t\t\tthis.pluralizedTypes = this.pluralizedTypes || makeDictionary();\n\n\t\t\tif (!this.pluralizedTypes.config) {\n\t\t\t\tthis.pluralizedTypes.config = 'config';\n\t\t\t}\n\t\t},\n\n    normalize: function(fullName) {\n    \treturn this._normalizeCache[fullName] || (this._normalizeCache[fullName] = this._normalize(fullName));\n\t\t},\n\t\t_normalize: function(fullName) {\n      // replace `.` with `/` in order to make nested controllers work in the following cases\n      // 1. `needs: ['posts/post']`\n      // 2. `{{render \"posts/post\"}}`\n      // 3. `this.render('posts/post')` from Route\n      var split = fullName.split(':');\n      if (split.length > 1) {\n        return split[0] + ':' + Ember.String.dasherize(split[1].replace(/\\./g, '/'));\n      } else {\n        return fullName;\n      }\n    },\n\t\t\n\t\tpluralize: function(type) {\n\t\t\treturn this.pluralizedTypes[type] || (this.pluralizedTypes[type] = type + 's');\n\t\t},\n\n\t\tpodBasedLookupWithPrefix: function(podPrefix, parsedName) {\n\t\t\tvar fullNameWithoutType = parsedName.fullNameWithoutType;\n\n\t\t\tif (parsedName.type === 'template') {\n\t\t\t\tfullNameWithoutType = fullNameWithoutType.replace(/^components\\//, '');\n\t\t\t}\n\n\t\t\treturn podPrefix + '/' + fullNameWithoutType + '/' + parsedName.type;\n\t\t},\n\n\t\tpodBasedModuleName: function(parsedName) {\n\t\t\tvar podPrefix = this.namespace.podModulePrefix || this.namespace.modulePrefix;\n\n\t\t\treturn this.podBasedLookupWithPrefix(podPrefix, parsedName);\n\t\t},\n\n\t\tpodBasedComponentsInSubdir: function(parsedName) {\n\t\t\tvar podPrefix = this.namespace.podModulePrefix || this.namespace.modulePrefix;\n\t\t\tpodPrefix = podPrefix + '/components';\n\n\t\t\tif (parsedName.type === 'component' || parsedName.fullNameWithoutType.match(/^components/)) {\n\t\t\t\treturn this.podBasedLookupWithPrefix(podPrefix, parsedName);\n\t\t\t}\n\t\t},\n\n\t\tmainModuleName: function(parsedName) {\n\t\t\t// if router:main or adapter:main look for a module with just the type first\n\t\t\tvar tmpModuleName = parsedName.prefix + '/' + parsedName.type;\n\n\t\t\tif (parsedName.fullNameWithoutType === 'main') {\n\t\t\t\treturn tmpModuleName;\n\t\t\t}\n\t\t},\n\n\t\tdefaultModuleName: function(parsedName) {\n\t\t\treturn parsedName.prefix + '/' + this.pluralize(parsedName.type) + '/' + parsedName.fullNameWithoutType;\n\t\t},\n\n\t\tprefix: function(parsedName) {\n\t\t\tvar tmpPrefix = this.namespace.modulePrefix;\n\n\t\t\tif (this.namespace[parsedName.type + 'Prefix']) {\n\t\t\t\ttmpPrefix = this.namespace[parsedName.type + 'Prefix'];\n\t\t\t}\n\n\t\t\treturn tmpPrefix;\n\t\t},\n\n\t\t/**\n\n\t\tA listing of functions to test for moduleName's based on the provided\n\t\t`parsedName`. This allows easy customization of additional module based\n\t\tlookup patterns.\n\n\t\t@property moduleNameLookupPatterns\n\t\t@returns {Ember.Array}\n\t\t*/\n\t\tmoduleNameLookupPatterns: Ember.computed(function(){\n\t\t\treturn Ember.A([\n\t\t\t\tthis.podBasedModuleName,\n\t\t\t\tthis.podBasedComponentsInSubdir,\n\t\t\t\tthis.mainModuleName,\n\t\t\t\tthis.defaultModuleName\n\t\t\t]);\n\t\t}),\n\n\t\tfindModuleName: function(parsedName, loggingDisabled){\n\t\t\tvar self = this;\n\t\t\tvar moduleName;\n\n\t\t\tthis.get('moduleNameLookupPatterns').find(function(item) {\n\t\t\t\tvar moduleEntries = requirejs.entries;\n\t\t\t\tvar tmpModuleName = item.call(self, parsedName);\n\n\t\t\t\t// allow treat all dashed and all underscored as the same thing\n\t\t\t\t// supports components with dashes and other stuff with underscores.\n\t\t\t\tif (tmpModuleName) {\n\t\t\t\t\ttmpModuleName = chooseModuleName(moduleEntries, tmpModuleName);\n\t\t\t\t}\n\n\t\t\t\tif (tmpModuleName && moduleEntries[tmpModuleName]) {\n\t\t\t\t\tif (!loggingDisabled) {\n\t\t\t\t\tself._logLookup(true, parsedName, tmpModuleName);\n\t\t\t\t}\n\n\t\t\t\tmoduleName = tmpModuleName;\n\t\t\t\t}\n\n\t\t\t\tif (!loggingDisabled) {\n\t\t\t\t\tself._logLookup(moduleName, parsedName, tmpModuleName);\n\t\t\t\t}\n\n\t\t\t\treturn moduleName;\n\t\t\t});\n\n\t\t\treturn moduleName;\n\t\t},\n\n\t\t// used by Ember.DefaultResolver.prototype._logLookup\n\t\tlookupDescription: function(fullName) {\n\t\t\tvar parsedName = this.parseName(fullName);\n\n\t\t\tvar moduleName = this.findModuleName(parsedName, true);\n\n\t\t\treturn moduleName;\n\t\t},\n\n\t\t// only needed until 1.6.0-beta.2 can be required\n\t\t_logLookup: function(found, parsedName, description) {\n\t\t\tif (!Ember.ENV.LOG_MODULE_RESOLVER && !parsedName.root.LOG_RESOLVER) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar symbol, padding;\n\n\t\t\tif (found) { symbol = '[✓]'; }\n\t\t\telse { symbol = '[ ]'; }\n\n\t\t\tif (parsedName.fullName.length > 60) {\n\t\t\t\tpadding = '.';\n\t\t\t} else {\n\t\t\t\tpadding = new Array(60 - parsedName.fullName.length).join('.');\n\t\t\t}\n\n\t\t\tif (!description) {\n\t\t\t\tdescription = this.lookupDescription(parsedName);\n\t\t\t}\n\n\t\t\tEmber.Logger.info(symbol, parsedName.fullName, padding, description);\n    }\n  });\n\n  Resolver['default'] = Resolver;\n  return Resolver;\n});\n\ndefine(\"resolver\",\n  [\"ember/resolver\"],\n  function (Resolver) {\n    Ember.deprecate('Importing/requiring Ember Resolver as \"resolver\" is deprecated, please use \"ember/resolver\" instead');\n    return Resolver;\n  });\n\n})();\n//@ sourceURL=ember-resolver/core");minispade.register('ember-resolver/initializers', "(function() {(function() {\n  \"use strict\";\n\n  Ember.Application.initializer({\n    name: 'container-debug-adapter',\n\n    initialize: function(container) {\n      var ContainerDebugAdapter = require('ember/container-debug-adapter');\n      var Resolver = require('ember/resolver');\n\n      container.register('container-debug-adapter:main', ContainerDebugAdapter);\n    }\n  });\n}());\n\n})();\n//@ sourceURL=ember-resolver/initializers");minispade.register('ember-resolver', "(function() {minispade.require('ember-resolver/core');\nminispade.require('ember-resolver/container-debug-adapter');\nminispade.require('ember-resolver/initializers');\n\n})();\n//@ sourceURL=ember-resolver");